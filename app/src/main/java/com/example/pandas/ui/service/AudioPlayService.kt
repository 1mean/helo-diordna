package com.example.pandas.ui.serviceimport android.app.Serviceimport android.content.Intentimport android.net.Uriimport android.os.*import android.util.Logimport com.android.android_sqlite.entity.MusicVoimport com.example.pandas.app.AppInfosimport com.example.pandas.biz.ext.getMusicUrlimport com.example.pandas.biz.interaction.AudioServiceListenerimport com.google.android.exoplayer2.ExoPlayerimport com.google.android.exoplayer2.MediaItemimport com.google.android.exoplayer2.PlaybackExceptionimport com.google.android.exoplayer2.Playerimport com.google.android.exoplayer2.Player.*import com.google.android.exoplayer2.util.Utilimport java.io.Fileimport java.lang.ref.WeakReferenceimport java.util.*/** * @description: AudioPlayService * @author: dongyiming * @date: 3/4/22 2:54 下午 * @version: v1.0 */public class AudioPlayService : Service() {    private val MAX_UPDATE_INTERVAL_MS = 1000L    private var _mPlayer: ExoPlayer? = null    private val mPlayer get() = _mPlayer!!    private val STATE_PAUSE = 5    private val mBinder: LocalBinder by lazy { LocalBinder(this) }    inner class LocalBinder() : Binder() {        private var mService:WeakReference<AudioPlayService>? = null        constructor(service: AudioPlayService) : this() {            this.mService = WeakReference(service)        }        fun getService(): AudioPlayService? {            return mService!!.get()        }    }    //绑定服务时才会调用，必须实现的唯一方法    override fun onBind(intent: Intent?): IBinder {//        val audioUrl = intent?.getStringExtra("url")//        audioUrl?.let {//            startExoPlayer(it)//        }        return mBinder    }    override fun onCreate() {//在调用 onStartCommand() 或 onBind() 之前        super.onCreate()        initExoPlayer()    }    /**     * 每次通过startService()方法启动Service时都会被回调，调用 stopSelf() 或 stopService() 来停止服务     * @param:     *      flags     *          - 0：正常状态下的传值     *          - START_FLAG_REDELIVERY：这个值代表了onStartCommand方法的返回值为START_REDELIVER_INTENT     *          - START_FLAG_RETRY：当onStartCommand调用后一直没有返回值时，会尝试重新去调用onStartCommand()     *      startId : 当前服务的唯一ID，与stopSelfResult(startId)配合使用，stopSelfResult可以更安全地根据ID停止服务     * @return:     *      START_STICKY：进程被清理，service保留在已开始状态，不保留intent。尝试重建service，调用该方法，intent为空     *      START_NOT_STICKY：果Service所在的进程，在执行了onStartCommand方法后，被清理了，则系统不会重新启动此Service     *      START_REDELIVER_INTENT：进程被清理，重建service，调用该方法，传入之前的最后一个intent     *      START_STICKY_COMPATIBILITY：不能保证被清理后onStartCommand方法一定会被重新调用     */    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {        val audioUrl = intent?.getStringExtra("url")        audioUrl?.let {            startExoPlayer(it)        }        return START_NOT_STICKY    }    override fun onDestroy() {        super.onDestroy()        releaseExoPlayer()    }    /**     * 初始化播放器     */    private fun initExoPlayer() {        if (_mPlayer == null) {            _mPlayer = ExoPlayer.Builder(this).build()            mPlayer.addListener(listener)        }    }    private fun releaseExoPlayer() {        mHandler.removeMessages(0)        mPlayer.release()        mPlayer.removeListener(listener)        _mPlayer = null    }    private val listener = object : Player.Listener {        //Called when the player starts or stops loading the source        //每隔9秒执行两次，先true后false        override fun onIsLoadingChanged(isLoading: Boolean) {        }        //检测播放过渡到另一个媒体item        //reason = 0: media item 重复播放当前歌曲        //reason = 1: 自动转换到下一个item        //reason = 2: seekTo()到另一个item        //reason = 3: playlist变化了，清空资源或是加入资源        override fun onMediaItemTransition(mediaItem: MediaItem?, reason: Int) {            super.onMediaItemTransition(mediaItem, reason)            when (reason) {                MEDIA_ITEM_TRANSITION_REASON_REPEAT -> {//0                }                MEDIA_ITEM_TRANSITION_REASON_AUTO -> {//1                    //当前播放的媒体文件在playlist里的位置，从0开始                    Log.d(                        AppInfos.DEBUG_LOG_TAG,                        "MediaIndex['next()']: ${mPlayer.currentMediaItemIndex}"                    )                    mListener?.initPlayView(mPlayer.currentMediaItemIndex)                    mListener?.getMusicDuration(getDuration(), mPlayer.duration)                }                MEDIA_ITEM_TRANSITION_REASON_SEEK -> {//2                    Log.d(                        AppInfos.DEBUG_LOG_TAG,                        "MediaIndex['seekTo()']: ${mPlayer.currentMediaItemIndex}"                    )                    mListener?.initPlayView(mPlayer.currentMediaItemIndex)                    mListener?.getMusicDuration(getDuration(), mPlayer.duration)                }                MEDIA_ITEM_TRANSITION_REASON_PLAYLIST_CHANGED -> {//3                }            }        }        //暂停 pause() 触发,暂停后 mplayer 的状态是为3：Player.STATE_READY        override fun onPlayWhenReadyChanged(playWhenReady: Boolean, reason: Int) {            if (!playWhenReady) {                mListener?.playStateChanged(STATE_PAUSE)            } else {                mListener?.playStateChanged(Player.STATE_READY)            }            super.onPlayWhenReadyChanged(playWhenReady, reason)        }        // 1，playWhenReady执行后，触发Player.STATE_BUFFERING        // 2，isLoading: true执行后，触发Player.STATE_READY        override fun onPlaybackStateChanged(playbackState: Int) {            when (playbackState) {                Player.STATE_BUFFERING -> {                    mHandler.sendEmptyMessage(0)                }                Player.STATE_READY -> {//拖动结束后会触发，音频播放结束前也会触发                    mListener?.getMusicDuration(getDuration(), mPlayer.duration)                }                Player.STATE_IDLE -> {//暂停不会触发                }                Player.STATE_ENDED -> {//播放结束                    mListener?.playStateChanged(Player.STATE_ENDED)                    mHandler.removeMessages(0)                }            }        }        override fun onPlayerError(error: PlaybackException) {        }    }    private val mHandler = object : Handler(Looper.getMainLooper()) {        override fun handleMessage(msg: Message) {            val currentPosition = mPlayer.currentPosition            val bufferedPosition = mPlayer.bufferedPosition            val formatBuilder = StringBuilder()            val formatter = Formatter(formatBuilder, Locale.getDefault())            val currentTime = Util.getStringForTime(formatBuilder, formatter, currentPosition)            mListener?.getCurrentPosition(currentTime)            mListener?.getTimeBarPosition(currentPosition, bufferedPosition)            sendEmptyMessageDelayed(0, MAX_UPDATE_INTERVAL_MS)        }    }    /*-对外方法---------------------------------------------------------------------------------------*/    private var mListener: AudioServiceListener? = null    fun addListener(mListener: AudioServiceListener) {        this.mListener = mListener    }    //消耗是226ms    fun startExoPlayer(fileName: String, musics: List<MusicVo>) {        var a = 0        musics.forEach { music ->            val musicUrl = getMusicUrl(this, music.fileName!!)            val mediaItem = MediaItem.fromUri(Uri.fromFile(File(musicUrl)))            mPlayer.addMediaItem(mediaItem)            if (music.fileName.equals(fileName)) {                a = mPlayer.mediaItemCount            }        }        //当播放的是position=0时，seekTo是不会触发一些列回调的        if (a == 1) {            mListener?.initPlayView(0)        } else {            mPlayer.seekTo(a - 1, 0)        }        mPlayer.repeatMode = Player.REPEAT_MODE_OFF        mPlayer.playWhenReady = true        mPlayer.prepare()    }    fun startExoPlayer(url: String) {        val firstLocalMediaItem = MediaItem.fromUri(Uri.fromFile(File(url)))        mPlayer.addMediaItem(firstLocalMediaItem)        mPlayer.playWhenReady = true        mPlayer.prepare()    }    fun getDuration(): String {        if (_mPlayer != null) {            val duration = mPlayer.duration            val stringBuilder = StringBuilder()            val formatter = Formatter(stringBuilder, Locale.getDefault())            return Util.getStringForTime(stringBuilder, formatter, duration)        }        return ""    }    //拖动到指定位置    fun seekToPosition(position: Long) {        if (_mPlayer != null) {            mPlayer.seekTo(position)        }    }    /**     * 暂停 setPlayWhenReady(false)     */    fun dispatchPause() {        if (mPlayer.isPlaying) {            mHandler.removeMessages(0)            mPlayer.pause()        } else {            mPlayer.playWhenReady = true//开始播放            mHandler.sendEmptyMessage(0)        }    }    /**     * 下一首/上一首     */    fun switchSong(isNext: Boolean) {        if (isNext) {            mPlayer.seekToNextMediaItem()        } else {            mPlayer.seekToPreviousMediaItem()        }    }    /**     * 切换到其他歌曲     */    fun seekToMediaItem(position: Int) {        mPlayer.seekTo(position, 0)    }}