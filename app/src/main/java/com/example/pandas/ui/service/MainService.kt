package com.example.pandas.ui.serviceimport android.app.Serviceimport android.content.Contextimport android.content.Intentimport android.os.*import android.util.Logimport com.google.android.exoplayer2.Player.*import java.lang.ref.WeakReferenceimport java.util.*/** * @description: MainService * * 最近项目中用到了service进行计时，在连接USB的情况下一切正常，但是拔掉USB后发现，手机进入休眠后service停止了工作。 * 最后通过 PowerManager.WakeLock 在屏幕休眠后保持cpu唤醒状态以使得service继续运行。 * 官网提醒：这个API会加剧耗电，所以在非必要情况下尽量不要使用。如果要使用尽量使用最低的等级，并在退出后释放资源。 * * wake lock一共有四个等级：        CPU         Screen          Keyboard * * PARTIAL_WAKE_LOCK              On          Off              Off * SCREEN_DIM_WAKE_LOCK           On          Dim              Off * SCREEN_BRIGHT_WAKE_LOCK        On          Bright           Off * FULL_WAKE_LOCK                 On          Bright           Bright * * * * 一、------安卓定时任务的两种方式 * ----1，Timer类 * ---------明显短板：不适用于那些需要长期在后台运行的定时任务。手机为了保护电池的休眠策略。 * Android 手机就会在长时间不操作的情况下自动让 CPU 进入到睡眠状态，这就有可能导致 Timer 中的定时任务无法正常运行 * ----2，Alarm机制 * ---------优势：具有唤醒CPU的功能。唤醒CPU不等于唤醒屏幕 * * 二、AlarmManager * ---------set(int type，long startTime，PendingIntent pi)   一次性定时器 * ---------setRepeating(int type，long startTime，long intervalTime，PendingIntent pi)  重复 * ---------setInexactRepeating（int type，long startTime，long intervalTime，PendingIntent pi） * ---重复执行的定时器，第三个方法更考虑电量，如系统在低电量条件下不会严格按照设定的时间间隔执行闹钟，因为系统可以调整报警的交付时间，使其同时触发，避免超过必要的唤醒设备 * * 闹钟类型 * - AlarmManager.ELAPSED_REALTIME：表示闹钟在手机睡眠状态下不可用，就是睡眠状态下不具备唤醒CPU的能力（跟普通Timer差不多了），该状态下闹钟使用相对时间,相对于系统启动开始 * - AlarmManager.ELAPSED_REALTIME_WAKEUP：表示闹钟在睡眠状态下会唤醒系统并执行提示功能，该状态下闹钟也使用相对时间 * - AlarmManager.RTC：表示闹钟在睡眠状态下不可用，该状态下闹钟使用绝对时间，即当前系统时间 * - AlarmManager.RTC_WAKEUP：表示闹钟在睡眠状态下会唤醒系统并执行提示功能，该状态下闹钟使用绝对时间 * * 三、使用handler或handler+timer+timertask * 四、使用ScheduledExecutorService * --------schedule(Runnable command, long delay, TimeUnit unit)：延迟任务，只执行一次(不会再次执行)，参数2为延迟时间 * 五、RXjava实现 * --------Observable.interval * 六、WorkManager实现定时任务 * --------WorkManager组件库里面提供了一个专门做周期性任务的类PeriodicWorkRequest * --------PeriodicWorkRequest类有一个限制条件最小的周期时间是15分钟，适合一些比较长时间的任务。如间隔一天、几天的任务 * * @author: dongyiming * @date: 3/4/22 2:54 下午 * @version: v1.0 */public class MainService : Service() {    private val mBinder: LocalBinder by lazy { LocalBinder(this) }    private var wakeLock: PowerManager.WakeLock? = null    inner class LocalBinder() : Binder() {        private var mService: WeakReference<MainService>? = null        constructor(service: MainService) : this() {            this.mService = WeakReference(service)        }        fun getService(): MainService? {            return mService!!.get()        }    }    fun haha() {        Log.e("3mean", "hahhahahah")    }    //绑定服务时才会调用，必须实现的唯一方法    override fun onBind(intent: Intent?): IBinder {        Log.e("3mean", "onBind")        return mBinder    }    override fun onCreate() {//在调用 onStartCommand() 或 onBind() 之前        Log.e("3mean", "onCreate")        super.onCreate()        val pm = getSystemService(Context.POWER_SERVICE) as PowerManager        wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, MainService::class.java.name)        wakeLock?.acquire()    }    /**     * 每次通过startService()方法启动Service时都会被回调，调用 stopSelf() 或 stopService() 来停止服务     * @param:     *      flags     *          - 0：正常状态下的传值     *          - START_FLAG_REDELIVERY：这个值代表了onStartCommand方法的返回值为START_REDELIVER_INTENT     *          - START_FLAG_RETRY：当onStartCommand调用后一直没有返回值时，会尝试重新去调用onStartCommand()     *      startId : 当前服务的唯一ID，与stopSelfResult(startId)配合使用，stopSelfResult可以更安全地根据ID停止服务     * @return:     *      START_STICKY：进程被清理，service保留在已开始状态，不保留intent。尝试重建service，调用该方法，intent为空     *      START_NOT_STICKY：果Service所在的进程，在执行了onStartCommand方法后，被清理了，则系统不会重新启动此Service     *      START_REDELIVER_INTENT：进程被清理，重建service，调用该方法，传入之前的最后一个intent     *      START_STICKY_COMPATIBILITY：不能保证被清理后onStartCommand方法一定会被重新调用     */    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {        Log.e("3mean", "onStartCommand")        return START_NOT_STICKY    }    override fun onDestroy() {        if (wakeLock != null) {            wakeLock!!.release()            wakeLock = null        }        super.onDestroy()    }    private val mHandler = object : Handler(Looper.getMainLooper()) {        override fun handleMessage(msg: Message) {            //sendEmptyMessageDelayed(0, MAX_UPDATE_INTERVAL_MS)        }    }    /*-对外方法---------------------------------------------------------------------------------------*/    fun startTimerTask() {    }}